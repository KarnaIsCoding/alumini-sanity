"use strict";
var types = require("@sanity/types");
function getStartPoint({
  node,
  path
}) {
  return types.isPortableTextTextBlock(node) ? {
    path: [...path, "children", {
      _key: node.children[0]._key
    }],
    offset: 0
  } : {
    path,
    offset: 0
  };
}
function isKeyedSegment(segment) {
  return typeof segment == "object" && segment !== null && "_key" in segment;
}
function reverseSelection(selection) {
  return selection.backward ? {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !1
  } : {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !0
  };
}
const getSelectionText = ({
  context
}) => {
  let text = "";
  const {
    value,
    selection
  } = context;
  if (!value || !selection)
    return text;
  const forwardSelection = selection.backward ? reverseSelection(selection) : selection;
  if (!forwardSelection)
    return text;
  for (const block of value)
    if (!(isKeyedSegment(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && types.isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (types.isPortableTextSpan(child)) {
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);
            break;
          }
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset);
            continue;
          }
          if (isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(0, forwardSelection.focus.offset);
            break;
          }
        }
      if (isKeyedSegment(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)
        break;
    }
  return text;
};
var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const getBlockTextBefore = ({
  context
}) => {
  if (!context.selection)
    return "";
  const point = (context.selection.backward ? reverseSelection(context.selection) : context.selection).anchor, key = isKeyedSegment(point.path[0]) ? point.path[0]._key : void 0, block = key ? context.value.find((block2) => block2._key === key) : void 0;
  if (!block)
    return "";
  const startOfBlock = getStartPoint({
    node: block,
    path: [{
      _key: block._key
    }]
  });
  return getSelectionText({
    context: __spreadProps(__spreadValues({}, context), {
      value: context.value,
      selection: {
        anchor: startOfBlock,
        focus: point
      }
    })
  });
};
exports.getBlockTextBefore = getBlockTextBefore;
exports.getSelectionText = getSelectionText;
//# sourceMappingURL=selector.get-text-before.cjs.map
