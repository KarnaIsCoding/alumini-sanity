{"version":3,"file":"selectors.cjs","sources":["../../src/behavior-actions/behavior.guards.ts","../../src/selectors/selectors.ts"],"sourcesContent":["import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @alpha\n */\nexport const selectionIsCollapsed: EditorSelector<boolean> = ({context}) => {\n  return (\n    JSON.stringify(context.selection?.anchor.path) ===\n      JSON.stringify(context.selection?.focus.path) &&\n    context.selection?.anchor.offset === context.selection?.focus.offset\n  )\n}\n\n/**\n * @alpha\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const guards = createGuards(context)\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusBlock = getFocusTextBlock({context})\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[2])\n      ? context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = ({context}) => {\n  const focusChild = getFocusChild({context})\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @alpha\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @alpha\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[context.value.length - 1]\n    ? context.value[context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @alpha\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @alpha\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @alpha\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @alpha\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock({context})\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @alpha\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock({context})\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n"],"names":["createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","selectionIsCollapsed","context","JSON","stringify","selection","anchor","path","focus","offset","getFocusBlock","key","isKeySegment","_key","undefined","node","value","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isPortableTextSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock"],"mappings":"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"}